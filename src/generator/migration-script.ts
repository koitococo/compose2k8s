import type { AnalysisResult, AnalyzedService } from '../types/analysis.js';
import { toK8sName } from '../utils/k8s-names.js';

export interface MigrationScript {
  filename: string;
  content: string;
  serviceName: string;
  description: string;
}

/**
 * Generate database migration scripts based on service types.
 */
export function generateMigrationScripts(
  analysis: AnalysisResult,
  selectedServices: string[],
  namespace: string,
): MigrationScript[] {
  const scripts: MigrationScript[] = [];

  for (const svcName of selectedServices) {
    const svc = analysis.services[svcName];
    if (!svc || svc.category !== 'database') continue;

    const dbType = detectDatabaseType(svc);
    if (!dbType) continue;

    const script = generateDbMigrationScript(svcName, svc, dbType, namespace);
    if (script) scripts.push(script);
  }

  return scripts;
}

type DbType = 'postgres' | 'mysql' | 'mongo' | 'redis';

function detectDatabaseType(svc: AnalyzedService): DbType | null {
  const image = svc.service.image?.toLowerCase() ?? '';
  if (image.includes('postgres')) return 'postgres';
  if (image.includes('mysql') || image.includes('mariadb')) return 'mysql';
  if (image.includes('mongo')) return 'mongo';
  if (image.includes('redis')) return 'redis';
  return null;
}

function generateDbMigrationScript(
  svcName: string,
  svc: AnalyzedService,
  dbType: DbType,
  namespace: string,
): MigrationScript | null {
  const k8sName = toK8sName(svcName);
  const ns = namespace || 'default';

  switch (dbType) {
    case 'postgres':
      return {
        filename: `migrate-${k8sName}.sh`,
        content: postgresScript(k8sName, svc, ns),
        serviceName: svcName,
        description: `PostgreSQL migration script for ${svcName} (pg_dump/pg_restore)`,
      };
    case 'mysql':
      return {
        filename: `migrate-${k8sName}.sh`,
        content: mysqlScript(k8sName, svc, ns),
        serviceName: svcName,
        description: `MySQL migration script for ${svcName} (mysqldump/mysql)`,
      };
    case 'mongo':
      return {
        filename: `migrate-${k8sName}.sh`,
        content: mongoScript(k8sName, svc, ns),
        serviceName: svcName,
        description: `MongoDB migration script for ${svcName} (mongodump/mongorestore)`,
      };
    case 'redis':
      return {
        filename: `migrate-${k8sName}.sh`,
        content: redisScript(k8sName, ns),
        serviceName: svcName,
        description: `Redis migration script for ${svcName} (BGSAVE + copy)`,
      };
    default:
      return null;
  }
}

function postgresScript(k8sName: string, svc: AnalyzedService, ns: string): string {
  const dbUser = svc.service.environment.POSTGRES_USER || 'postgres';
  const dbName = svc.service.environment.POSTGRES_DB || 'postgres';

  return `#!/usr/bin/env bash
set -euo pipefail

# PostgreSQL Migration Script for ${k8sName}
# Generated by compose2k8s
#
# This script helps migrate data from a Docker Compose PostgreSQL instance
# to a Kubernetes PostgreSQL instance.

NAMESPACE="${ns}"
SERVICE="${k8sName}"
DB_USER="${dbUser}"
DB_NAME="${dbName}"
DUMP_FILE="pg_dump_\${DB_NAME}_$(date +%Y%m%d_%H%M%S).sql"

echo "=== PostgreSQL Migration: ${k8sName} ==="

# Step 1: Dump from source (Docker Compose)
echo "[1/3] Dumping database from Docker Compose..."
echo "  Run on your Docker host:"
echo "    docker compose exec ${k8sName} pg_dump -U \${DB_USER} -d \${DB_NAME} > \${DUMP_FILE}"
echo ""

# Step 2: Copy dump to K8s pod
echo "[2/3] Copying dump to Kubernetes pod..."
POD=$(kubectl get pods -n \${NAMESPACE} -l app.kubernetes.io/name=\${SERVICE} -o jsonpath='{.items[0].metadata.name}')
echo "  kubectl cp \${DUMP_FILE} \${NAMESPACE}/\${POD}:/tmp/\${DUMP_FILE}"
echo ""

# Step 3: Restore in K8s
echo "[3/3] Restoring database in Kubernetes..."
echo "  kubectl exec -n \${NAMESPACE} \${POD} -- psql -U \${DB_USER} -d \${DB_NAME} -f /tmp/\${DUMP_FILE}"
echo ""

echo "=== Migration steps printed. Review and execute manually. ==="
echo ""
echo "Or run the full automated migration:"
echo "  docker compose exec ${k8sName} pg_dump -U \${DB_USER} -d \${DB_NAME} > \${DUMP_FILE}"
echo "  kubectl cp \${DUMP_FILE} \${NAMESPACE}/\${POD}:/tmp/\${DUMP_FILE}"
echo "  kubectl exec -n \${NAMESPACE} \${POD} -- psql -U \${DB_USER} -d \${DB_NAME} -f /tmp/\${DUMP_FILE}"
`;
}

function mysqlScript(k8sName: string, svc: AnalyzedService, ns: string): string {
  const dbUser = svc.service.environment.MYSQL_USER || 'root';
  const dbName = svc.service.environment.MYSQL_DATABASE || 'mysql';

  return `#!/usr/bin/env bash
set -euo pipefail

# MySQL Migration Script for ${k8sName}
# Generated by compose2k8s

NAMESPACE="${ns}"
SERVICE="${k8sName}"
DB_USER="${dbUser}"
DB_NAME="${dbName}"
DUMP_FILE="mysql_dump_\${DB_NAME}_$(date +%Y%m%d_%H%M%S).sql"

echo "=== MySQL Migration: ${k8sName} ==="

# Step 1: Dump from source
echo "[1/3] Dumping database from Docker Compose..."
echo "  docker compose exec ${k8sName} mysqldump -u \${DB_USER} -p \${DB_NAME} > \${DUMP_FILE}"
echo ""

# Step 2: Copy to K8s
echo "[2/3] Copying dump to Kubernetes pod..."
POD=$(kubectl get pods -n \${NAMESPACE} -l app.kubernetes.io/name=\${SERVICE} -o jsonpath='{.items[0].metadata.name}')
echo "  kubectl cp \${DUMP_FILE} \${NAMESPACE}/\${POD}:/tmp/\${DUMP_FILE}"
echo ""

# Step 3: Restore
echo "[3/3] Restoring database in Kubernetes..."
echo "  kubectl exec -n \${NAMESPACE} \${POD} -- mysql -u \${DB_USER} -p \${DB_NAME} < /tmp/\${DUMP_FILE}"
echo ""

echo "=== Review and execute the above commands manually. ==="
`;
}

function mongoScript(k8sName: string, svc: AnalyzedService, ns: string): string {
  const dbName = svc.service.environment.MONGO_INITDB_DATABASE || 'admin';

  return `#!/usr/bin/env bash
set -euo pipefail

# MongoDB Migration Script for ${k8sName}
# Generated by compose2k8s

NAMESPACE="${ns}"
SERVICE="${k8sName}"
DB_NAME="${dbName}"
DUMP_DIR="mongodump_\${DB_NAME}_$(date +%Y%m%d_%H%M%S)"

echo "=== MongoDB Migration: ${k8sName} ==="

# Step 1: Dump from source
echo "[1/3] Dumping database from Docker Compose..."
echo "  docker compose exec ${k8sName} mongodump --db \${DB_NAME} --out /tmp/\${DUMP_DIR}"
echo "  docker compose cp ${k8sName}:/tmp/\${DUMP_DIR} ./\${DUMP_DIR}"
echo ""

# Step 2: Copy to K8s
echo "[2/3] Copying dump to Kubernetes pod..."
POD=$(kubectl get pods -n \${NAMESPACE} -l app.kubernetes.io/name=\${SERVICE} -o jsonpath='{.items[0].metadata.name}')
echo "  kubectl cp ./\${DUMP_DIR} \${NAMESPACE}/\${POD}:/tmp/\${DUMP_DIR}"
echo ""

# Step 3: Restore
echo "[3/3] Restoring database in Kubernetes..."
echo "  kubectl exec -n \${NAMESPACE} \${POD} -- mongorestore --db \${DB_NAME} /tmp/\${DUMP_DIR}/\${DB_NAME}"
echo ""

echo "=== Review and execute the above commands manually. ==="
`;
}

function redisScript(k8sName: string, ns: string): string {
  return `#!/usr/bin/env bash
set -euo pipefail

# Redis Migration Script for ${k8sName}
# Generated by compose2k8s

NAMESPACE="${ns}"
SERVICE="${k8sName}"
DUMP_FILE="redis_dump.rdb"

echo "=== Redis Migration: ${k8sName} ==="

# Step 1: Trigger BGSAVE and copy RDB
echo "[1/3] Triggering BGSAVE in Docker Compose Redis..."
echo "  docker compose exec ${k8sName} redis-cli BGSAVE"
echo "  docker compose cp ${k8sName}:/data/dump.rdb ./\${DUMP_FILE}"
echo ""

# Step 2: Copy to K8s
echo "[2/3] Copying RDB to Kubernetes pod..."
POD=$(kubectl get pods -n \${NAMESPACE} -l app.kubernetes.io/name=\${SERVICE} -o jsonpath='{.items[0].metadata.name}')
echo "  kubectl cp ./\${DUMP_FILE} \${NAMESPACE}/\${POD}:/data/dump.rdb"
echo ""

# Step 3: Restart Redis to load RDB
echo "[3/3] Restarting Redis to load dump..."
echo "  kubectl delete pod -n \${NAMESPACE} \${POD}"
echo "  # Pod will be recreated by StatefulSet/Deployment and load the RDB"
echo ""

echo "=== Review and execute the above commands manually. ==="
`;
}
